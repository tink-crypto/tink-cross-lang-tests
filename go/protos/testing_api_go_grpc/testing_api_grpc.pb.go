// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.26.1
// source: go/protos/testing_api.proto

package testing_api_go_proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Metadata_GetServerInfo_FullMethodName = "/tink_testing_api.Metadata/GetServerInfo"
)

// MetadataClient is the client API for Metadata service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MetadataClient interface {
	// Returns some server information. A test may use this information to verify
	// that it is talking to the right server.
	GetServerInfo(ctx context.Context, in *ServerInfoRequest, opts ...grpc.CallOption) (*ServerInfoResponse, error)
}

type metadataClient struct {
	cc grpc.ClientConnInterface
}

func NewMetadataClient(cc grpc.ClientConnInterface) MetadataClient {
	return &metadataClient{cc}
}

func (c *metadataClient) GetServerInfo(ctx context.Context, in *ServerInfoRequest, opts ...grpc.CallOption) (*ServerInfoResponse, error) {
	out := new(ServerInfoResponse)
	err := c.cc.Invoke(ctx, Metadata_GetServerInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetadataServer is the server API for Metadata service.
// All implementations must embed UnimplementedMetadataServer
// for forward compatibility
type MetadataServer interface {
	// Returns some server information. A test may use this information to verify
	// that it is talking to the right server.
	GetServerInfo(context.Context, *ServerInfoRequest) (*ServerInfoResponse, error)
	mustEmbedUnimplementedMetadataServer()
}

// UnimplementedMetadataServer must be embedded to have forward compatible implementations.
type UnimplementedMetadataServer struct {
}

func (UnimplementedMetadataServer) GetServerInfo(context.Context, *ServerInfoRequest) (*ServerInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServerInfo not implemented")
}
func (UnimplementedMetadataServer) mustEmbedUnimplementedMetadataServer() {}

// UnsafeMetadataServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MetadataServer will
// result in compilation errors.
type UnsafeMetadataServer interface {
	mustEmbedUnimplementedMetadataServer()
}

func RegisterMetadataServer(s grpc.ServiceRegistrar, srv MetadataServer) {
	s.RegisterService(&Metadata_ServiceDesc, srv)
}

func _Metadata_GetServerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataServer).GetServerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Metadata_GetServerInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataServer).GetServerInfo(ctx, req.(*ServerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Metadata_ServiceDesc is the grpc.ServiceDesc for Metadata service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Metadata_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tink_testing_api.Metadata",
	HandlerType: (*MetadataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetServerInfo",
			Handler:    _Metadata_GetServerInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/protos/testing_api.proto",
}

const (
	Keyset_GetTemplate_FullMethodName    = "/tink_testing_api.Keyset/GetTemplate"
	Keyset_Generate_FullMethodName       = "/tink_testing_api.Keyset/Generate"
	Keyset_Public_FullMethodName         = "/tink_testing_api.Keyset/Public"
	Keyset_ToJson_FullMethodName         = "/tink_testing_api.Keyset/ToJson"
	Keyset_FromJson_FullMethodName       = "/tink_testing_api.Keyset/FromJson"
	Keyset_ReadEncrypted_FullMethodName  = "/tink_testing_api.Keyset/ReadEncrypted"
	Keyset_WriteEncrypted_FullMethodName = "/tink_testing_api.Keyset/WriteEncrypted"
)

// KeysetClient is the client API for Keyset service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KeysetClient interface {
	// Generates a key template from a key template name.
	GetTemplate(ctx context.Context, in *KeysetTemplateRequest, opts ...grpc.CallOption) (*KeysetTemplateResponse, error)
	// Generates a new keyset from a template.
	Generate(ctx context.Context, in *KeysetGenerateRequest, opts ...grpc.CallOption) (*KeysetGenerateResponse, error)
	// Generates a public-key keyset from a private-key keyset.
	Public(ctx context.Context, in *KeysetPublicRequest, opts ...grpc.CallOption) (*KeysetPublicResponse, error)
	// Converts a Keyset from Binary to Json Format
	ToJson(ctx context.Context, in *KeysetToJsonRequest, opts ...grpc.CallOption) (*KeysetToJsonResponse, error)
	// Converts a Keyset from Json to Binary Format
	FromJson(ctx context.Context, in *KeysetFromJsonRequest, opts ...grpc.CallOption) (*KeysetFromJsonResponse, error)
	// Reads an encrypted keyset using KeysetHandle.read() or
	// KeysetHandle.readWithAssociatedData() and the BinaryKeysetReader.
	ReadEncrypted(ctx context.Context, in *KeysetReadEncryptedRequest, opts ...grpc.CallOption) (*KeysetReadEncryptedResponse, error)
	// Writes an encrypted keyset using KeysetHandle.write() or
	// KeysetHandle.writeWithAssociatedData() and the BinaryKeysetWriter.
	WriteEncrypted(ctx context.Context, in *KeysetWriteEncryptedRequest, opts ...grpc.CallOption) (*KeysetWriteEncryptedResponse, error)
}

type keysetClient struct {
	cc grpc.ClientConnInterface
}

func NewKeysetClient(cc grpc.ClientConnInterface) KeysetClient {
	return &keysetClient{cc}
}

func (c *keysetClient) GetTemplate(ctx context.Context, in *KeysetTemplateRequest, opts ...grpc.CallOption) (*KeysetTemplateResponse, error) {
	out := new(KeysetTemplateResponse)
	err := c.cc.Invoke(ctx, Keyset_GetTemplate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysetClient) Generate(ctx context.Context, in *KeysetGenerateRequest, opts ...grpc.CallOption) (*KeysetGenerateResponse, error) {
	out := new(KeysetGenerateResponse)
	err := c.cc.Invoke(ctx, Keyset_Generate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysetClient) Public(ctx context.Context, in *KeysetPublicRequest, opts ...grpc.CallOption) (*KeysetPublicResponse, error) {
	out := new(KeysetPublicResponse)
	err := c.cc.Invoke(ctx, Keyset_Public_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysetClient) ToJson(ctx context.Context, in *KeysetToJsonRequest, opts ...grpc.CallOption) (*KeysetToJsonResponse, error) {
	out := new(KeysetToJsonResponse)
	err := c.cc.Invoke(ctx, Keyset_ToJson_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysetClient) FromJson(ctx context.Context, in *KeysetFromJsonRequest, opts ...grpc.CallOption) (*KeysetFromJsonResponse, error) {
	out := new(KeysetFromJsonResponse)
	err := c.cc.Invoke(ctx, Keyset_FromJson_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysetClient) ReadEncrypted(ctx context.Context, in *KeysetReadEncryptedRequest, opts ...grpc.CallOption) (*KeysetReadEncryptedResponse, error) {
	out := new(KeysetReadEncryptedResponse)
	err := c.cc.Invoke(ctx, Keyset_ReadEncrypted_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysetClient) WriteEncrypted(ctx context.Context, in *KeysetWriteEncryptedRequest, opts ...grpc.CallOption) (*KeysetWriteEncryptedResponse, error) {
	out := new(KeysetWriteEncryptedResponse)
	err := c.cc.Invoke(ctx, Keyset_WriteEncrypted_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KeysetServer is the server API for Keyset service.
// All implementations must embed UnimplementedKeysetServer
// for forward compatibility
type KeysetServer interface {
	// Generates a key template from a key template name.
	GetTemplate(context.Context, *KeysetTemplateRequest) (*KeysetTemplateResponse, error)
	// Generates a new keyset from a template.
	Generate(context.Context, *KeysetGenerateRequest) (*KeysetGenerateResponse, error)
	// Generates a public-key keyset from a private-key keyset.
	Public(context.Context, *KeysetPublicRequest) (*KeysetPublicResponse, error)
	// Converts a Keyset from Binary to Json Format
	ToJson(context.Context, *KeysetToJsonRequest) (*KeysetToJsonResponse, error)
	// Converts a Keyset from Json to Binary Format
	FromJson(context.Context, *KeysetFromJsonRequest) (*KeysetFromJsonResponse, error)
	// Reads an encrypted keyset using KeysetHandle.read() or
	// KeysetHandle.readWithAssociatedData() and the BinaryKeysetReader.
	ReadEncrypted(context.Context, *KeysetReadEncryptedRequest) (*KeysetReadEncryptedResponse, error)
	// Writes an encrypted keyset using KeysetHandle.write() or
	// KeysetHandle.writeWithAssociatedData() and the BinaryKeysetWriter.
	WriteEncrypted(context.Context, *KeysetWriteEncryptedRequest) (*KeysetWriteEncryptedResponse, error)
	mustEmbedUnimplementedKeysetServer()
}

// UnimplementedKeysetServer must be embedded to have forward compatible implementations.
type UnimplementedKeysetServer struct {
}

func (UnimplementedKeysetServer) GetTemplate(context.Context, *KeysetTemplateRequest) (*KeysetTemplateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTemplate not implemented")
}
func (UnimplementedKeysetServer) Generate(context.Context, *KeysetGenerateRequest) (*KeysetGenerateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Generate not implemented")
}
func (UnimplementedKeysetServer) Public(context.Context, *KeysetPublicRequest) (*KeysetPublicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Public not implemented")
}
func (UnimplementedKeysetServer) ToJson(context.Context, *KeysetToJsonRequest) (*KeysetToJsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToJson not implemented")
}
func (UnimplementedKeysetServer) FromJson(context.Context, *KeysetFromJsonRequest) (*KeysetFromJsonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FromJson not implemented")
}
func (UnimplementedKeysetServer) ReadEncrypted(context.Context, *KeysetReadEncryptedRequest) (*KeysetReadEncryptedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadEncrypted not implemented")
}
func (UnimplementedKeysetServer) WriteEncrypted(context.Context, *KeysetWriteEncryptedRequest) (*KeysetWriteEncryptedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteEncrypted not implemented")
}
func (UnimplementedKeysetServer) mustEmbedUnimplementedKeysetServer() {}

// UnsafeKeysetServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KeysetServer will
// result in compilation errors.
type UnsafeKeysetServer interface {
	mustEmbedUnimplementedKeysetServer()
}

func RegisterKeysetServer(s grpc.ServiceRegistrar, srv KeysetServer) {
	s.RegisterService(&Keyset_ServiceDesc, srv)
}

func _Keyset_GetTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeysetTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysetServer).GetTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Keyset_GetTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysetServer).GetTemplate(ctx, req.(*KeysetTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keyset_Generate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeysetGenerateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysetServer).Generate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Keyset_Generate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysetServer).Generate(ctx, req.(*KeysetGenerateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keyset_Public_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeysetPublicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysetServer).Public(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Keyset_Public_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysetServer).Public(ctx, req.(*KeysetPublicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keyset_ToJson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeysetToJsonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysetServer).ToJson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Keyset_ToJson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysetServer).ToJson(ctx, req.(*KeysetToJsonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keyset_FromJson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeysetFromJsonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysetServer).FromJson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Keyset_FromJson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysetServer).FromJson(ctx, req.(*KeysetFromJsonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keyset_ReadEncrypted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeysetReadEncryptedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysetServer).ReadEncrypted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Keyset_ReadEncrypted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysetServer).ReadEncrypted(ctx, req.(*KeysetReadEncryptedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keyset_WriteEncrypted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeysetWriteEncryptedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysetServer).WriteEncrypted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Keyset_WriteEncrypted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysetServer).WriteEncrypted(ctx, req.(*KeysetWriteEncryptedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Keyset_ServiceDesc is the grpc.ServiceDesc for Keyset service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Keyset_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tink_testing_api.Keyset",
	HandlerType: (*KeysetServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTemplate",
			Handler:    _Keyset_GetTemplate_Handler,
		},
		{
			MethodName: "Generate",
			Handler:    _Keyset_Generate_Handler,
		},
		{
			MethodName: "Public",
			Handler:    _Keyset_Public_Handler,
		},
		{
			MethodName: "ToJson",
			Handler:    _Keyset_ToJson_Handler,
		},
		{
			MethodName: "FromJson",
			Handler:    _Keyset_FromJson_Handler,
		},
		{
			MethodName: "ReadEncrypted",
			Handler:    _Keyset_ReadEncrypted_Handler,
		},
		{
			MethodName: "WriteEncrypted",
			Handler:    _Keyset_WriteEncrypted_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/protos/testing_api.proto",
}

const (
	Aead_Create_FullMethodName  = "/tink_testing_api.Aead/Create"
	Aead_Encrypt_FullMethodName = "/tink_testing_api.Aead/Encrypt"
	Aead_Decrypt_FullMethodName = "/tink_testing_api.Aead/Decrypt"
)

// AeadClient is the client API for Aead service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AeadClient interface {
	// Creates an Aead object without using it.
	Create(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error)
	// Encrypts a plaintext with the provided keyset. The client must call
	// "Create" first to see if creation succeeds before calling this.
	Encrypt(ctx context.Context, in *AeadEncryptRequest, opts ...grpc.CallOption) (*AeadEncryptResponse, error)
	// Decrypts a ciphertext with the provided keyset. The client must call
	// "Create" first to see if creation succeeds before calling this.
	Decrypt(ctx context.Context, in *AeadDecryptRequest, opts ...grpc.CallOption) (*AeadDecryptResponse, error)
}

type aeadClient struct {
	cc grpc.ClientConnInterface
}

func NewAeadClient(cc grpc.ClientConnInterface) AeadClient {
	return &aeadClient{cc}
}

func (c *aeadClient) Create(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error) {
	out := new(CreationResponse)
	err := c.cc.Invoke(ctx, Aead_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aeadClient) Encrypt(ctx context.Context, in *AeadEncryptRequest, opts ...grpc.CallOption) (*AeadEncryptResponse, error) {
	out := new(AeadEncryptResponse)
	err := c.cc.Invoke(ctx, Aead_Encrypt_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aeadClient) Decrypt(ctx context.Context, in *AeadDecryptRequest, opts ...grpc.CallOption) (*AeadDecryptResponse, error) {
	out := new(AeadDecryptResponse)
	err := c.cc.Invoke(ctx, Aead_Decrypt_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AeadServer is the server API for Aead service.
// All implementations must embed UnimplementedAeadServer
// for forward compatibility
type AeadServer interface {
	// Creates an Aead object without using it.
	Create(context.Context, *CreationRequest) (*CreationResponse, error)
	// Encrypts a plaintext with the provided keyset. The client must call
	// "Create" first to see if creation succeeds before calling this.
	Encrypt(context.Context, *AeadEncryptRequest) (*AeadEncryptResponse, error)
	// Decrypts a ciphertext with the provided keyset. The client must call
	// "Create" first to see if creation succeeds before calling this.
	Decrypt(context.Context, *AeadDecryptRequest) (*AeadDecryptResponse, error)
	mustEmbedUnimplementedAeadServer()
}

// UnimplementedAeadServer must be embedded to have forward compatible implementations.
type UnimplementedAeadServer struct {
}

func (UnimplementedAeadServer) Create(context.Context, *CreationRequest) (*CreationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedAeadServer) Encrypt(context.Context, *AeadEncryptRequest) (*AeadEncryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Encrypt not implemented")
}
func (UnimplementedAeadServer) Decrypt(context.Context, *AeadDecryptRequest) (*AeadDecryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Decrypt not implemented")
}
func (UnimplementedAeadServer) mustEmbedUnimplementedAeadServer() {}

// UnsafeAeadServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AeadServer will
// result in compilation errors.
type UnsafeAeadServer interface {
	mustEmbedUnimplementedAeadServer()
}

func RegisterAeadServer(s grpc.ServiceRegistrar, srv AeadServer) {
	s.RegisterService(&Aead_ServiceDesc, srv)
}

func _Aead_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AeadServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Aead_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AeadServer).Create(ctx, req.(*CreationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Aead_Encrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AeadEncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AeadServer).Encrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Aead_Encrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AeadServer).Encrypt(ctx, req.(*AeadEncryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Aead_Decrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AeadDecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AeadServer).Decrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Aead_Decrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AeadServer).Decrypt(ctx, req.(*AeadDecryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Aead_ServiceDesc is the grpc.ServiceDesc for Aead service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Aead_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tink_testing_api.Aead",
	HandlerType: (*AeadServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Aead_Create_Handler,
		},
		{
			MethodName: "Encrypt",
			Handler:    _Aead_Encrypt_Handler,
		},
		{
			MethodName: "Decrypt",
			Handler:    _Aead_Decrypt_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/protos/testing_api.proto",
}

const (
	DeterministicAead_Create_FullMethodName                   = "/tink_testing_api.DeterministicAead/Create"
	DeterministicAead_EncryptDeterministically_FullMethodName = "/tink_testing_api.DeterministicAead/EncryptDeterministically"
	DeterministicAead_DecryptDeterministically_FullMethodName = "/tink_testing_api.DeterministicAead/DecryptDeterministically"
)

// DeterministicAeadClient is the client API for DeterministicAead service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DeterministicAeadClient interface {
	// Creates a Deterministic AEAD object without using it.
	Create(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error)
	// Encrypts a plaintext with the provided keyset. The client must call
	// "Create" first to see if creation succeeds before calling
	// this.
	EncryptDeterministically(ctx context.Context, in *DeterministicAeadEncryptRequest, opts ...grpc.CallOption) (*DeterministicAeadEncryptResponse, error)
	// Decrypts a ciphertext with the provided keyset. The client must call
	// "Create" first to see if creation succeeds before calling
	// this.
	DecryptDeterministically(ctx context.Context, in *DeterministicAeadDecryptRequest, opts ...grpc.CallOption) (*DeterministicAeadDecryptResponse, error)
}

type deterministicAeadClient struct {
	cc grpc.ClientConnInterface
}

func NewDeterministicAeadClient(cc grpc.ClientConnInterface) DeterministicAeadClient {
	return &deterministicAeadClient{cc}
}

func (c *deterministicAeadClient) Create(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error) {
	out := new(CreationResponse)
	err := c.cc.Invoke(ctx, DeterministicAead_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deterministicAeadClient) EncryptDeterministically(ctx context.Context, in *DeterministicAeadEncryptRequest, opts ...grpc.CallOption) (*DeterministicAeadEncryptResponse, error) {
	out := new(DeterministicAeadEncryptResponse)
	err := c.cc.Invoke(ctx, DeterministicAead_EncryptDeterministically_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deterministicAeadClient) DecryptDeterministically(ctx context.Context, in *DeterministicAeadDecryptRequest, opts ...grpc.CallOption) (*DeterministicAeadDecryptResponse, error) {
	out := new(DeterministicAeadDecryptResponse)
	err := c.cc.Invoke(ctx, DeterministicAead_DecryptDeterministically_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeterministicAeadServer is the server API for DeterministicAead service.
// All implementations must embed UnimplementedDeterministicAeadServer
// for forward compatibility
type DeterministicAeadServer interface {
	// Creates a Deterministic AEAD object without using it.
	Create(context.Context, *CreationRequest) (*CreationResponse, error)
	// Encrypts a plaintext with the provided keyset. The client must call
	// "Create" first to see if creation succeeds before calling
	// this.
	EncryptDeterministically(context.Context, *DeterministicAeadEncryptRequest) (*DeterministicAeadEncryptResponse, error)
	// Decrypts a ciphertext with the provided keyset. The client must call
	// "Create" first to see if creation succeeds before calling
	// this.
	DecryptDeterministically(context.Context, *DeterministicAeadDecryptRequest) (*DeterministicAeadDecryptResponse, error)
	mustEmbedUnimplementedDeterministicAeadServer()
}

// UnimplementedDeterministicAeadServer must be embedded to have forward compatible implementations.
type UnimplementedDeterministicAeadServer struct {
}

func (UnimplementedDeterministicAeadServer) Create(context.Context, *CreationRequest) (*CreationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedDeterministicAeadServer) EncryptDeterministically(context.Context, *DeterministicAeadEncryptRequest) (*DeterministicAeadEncryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptDeterministically not implemented")
}
func (UnimplementedDeterministicAeadServer) DecryptDeterministically(context.Context, *DeterministicAeadDecryptRequest) (*DeterministicAeadDecryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecryptDeterministically not implemented")
}
func (UnimplementedDeterministicAeadServer) mustEmbedUnimplementedDeterministicAeadServer() {}

// UnsafeDeterministicAeadServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeterministicAeadServer will
// result in compilation errors.
type UnsafeDeterministicAeadServer interface {
	mustEmbedUnimplementedDeterministicAeadServer()
}

func RegisterDeterministicAeadServer(s grpc.ServiceRegistrar, srv DeterministicAeadServer) {
	s.RegisterService(&DeterministicAead_ServiceDesc, srv)
}

func _DeterministicAead_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeterministicAeadServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeterministicAead_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeterministicAeadServer).Create(ctx, req.(*CreationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeterministicAead_EncryptDeterministically_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeterministicAeadEncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeterministicAeadServer).EncryptDeterministically(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeterministicAead_EncryptDeterministically_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeterministicAeadServer).EncryptDeterministically(ctx, req.(*DeterministicAeadEncryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeterministicAead_DecryptDeterministically_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeterministicAeadDecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeterministicAeadServer).DecryptDeterministically(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeterministicAead_DecryptDeterministically_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeterministicAeadServer).DecryptDeterministically(ctx, req.(*DeterministicAeadDecryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DeterministicAead_ServiceDesc is the grpc.ServiceDesc for DeterministicAead service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DeterministicAead_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tink_testing_api.DeterministicAead",
	HandlerType: (*DeterministicAeadServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _DeterministicAead_Create_Handler,
		},
		{
			MethodName: "EncryptDeterministically",
			Handler:    _DeterministicAead_EncryptDeterministically_Handler,
		},
		{
			MethodName: "DecryptDeterministically",
			Handler:    _DeterministicAead_DecryptDeterministically_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/protos/testing_api.proto",
}

const (
	StreamingAead_Create_FullMethodName  = "/tink_testing_api.StreamingAead/Create"
	StreamingAead_Encrypt_FullMethodName = "/tink_testing_api.StreamingAead/Encrypt"
	StreamingAead_Decrypt_FullMethodName = "/tink_testing_api.StreamingAead/Decrypt"
)

// StreamingAeadClient is the client API for StreamingAead service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StreamingAeadClient interface {
	// Creates a StreamingAead object without using it.
	Create(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error)
	// Encrypts a plaintext with the provided keyset. The client must call
	// "Create" first to see if creation succeeds before calling this.
	Encrypt(ctx context.Context, in *StreamingAeadEncryptRequest, opts ...grpc.CallOption) (*StreamingAeadEncryptResponse, error)
	// Decrypts a ciphertext with the provided keyset. The client must call
	// "Create" first to see if creation succeeds before calling this.
	Decrypt(ctx context.Context, in *StreamingAeadDecryptRequest, opts ...grpc.CallOption) (*StreamingAeadDecryptResponse, error)
}

type streamingAeadClient struct {
	cc grpc.ClientConnInterface
}

func NewStreamingAeadClient(cc grpc.ClientConnInterface) StreamingAeadClient {
	return &streamingAeadClient{cc}
}

func (c *streamingAeadClient) Create(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error) {
	out := new(CreationResponse)
	err := c.cc.Invoke(ctx, StreamingAead_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamingAeadClient) Encrypt(ctx context.Context, in *StreamingAeadEncryptRequest, opts ...grpc.CallOption) (*StreamingAeadEncryptResponse, error) {
	out := new(StreamingAeadEncryptResponse)
	err := c.cc.Invoke(ctx, StreamingAead_Encrypt_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamingAeadClient) Decrypt(ctx context.Context, in *StreamingAeadDecryptRequest, opts ...grpc.CallOption) (*StreamingAeadDecryptResponse, error) {
	out := new(StreamingAeadDecryptResponse)
	err := c.cc.Invoke(ctx, StreamingAead_Decrypt_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StreamingAeadServer is the server API for StreamingAead service.
// All implementations must embed UnimplementedStreamingAeadServer
// for forward compatibility
type StreamingAeadServer interface {
	// Creates a StreamingAead object without using it.
	Create(context.Context, *CreationRequest) (*CreationResponse, error)
	// Encrypts a plaintext with the provided keyset. The client must call
	// "Create" first to see if creation succeeds before calling this.
	Encrypt(context.Context, *StreamingAeadEncryptRequest) (*StreamingAeadEncryptResponse, error)
	// Decrypts a ciphertext with the provided keyset. The client must call
	// "Create" first to see if creation succeeds before calling this.
	Decrypt(context.Context, *StreamingAeadDecryptRequest) (*StreamingAeadDecryptResponse, error)
	mustEmbedUnimplementedStreamingAeadServer()
}

// UnimplementedStreamingAeadServer must be embedded to have forward compatible implementations.
type UnimplementedStreamingAeadServer struct {
}

func (UnimplementedStreamingAeadServer) Create(context.Context, *CreationRequest) (*CreationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedStreamingAeadServer) Encrypt(context.Context, *StreamingAeadEncryptRequest) (*StreamingAeadEncryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Encrypt not implemented")
}
func (UnimplementedStreamingAeadServer) Decrypt(context.Context, *StreamingAeadDecryptRequest) (*StreamingAeadDecryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Decrypt not implemented")
}
func (UnimplementedStreamingAeadServer) mustEmbedUnimplementedStreamingAeadServer() {}

// UnsafeStreamingAeadServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StreamingAeadServer will
// result in compilation errors.
type UnsafeStreamingAeadServer interface {
	mustEmbedUnimplementedStreamingAeadServer()
}

func RegisterStreamingAeadServer(s grpc.ServiceRegistrar, srv StreamingAeadServer) {
	s.RegisterService(&StreamingAead_ServiceDesc, srv)
}

func _StreamingAead_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamingAeadServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamingAead_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamingAeadServer).Create(ctx, req.(*CreationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamingAead_Encrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamingAeadEncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamingAeadServer).Encrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamingAead_Encrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamingAeadServer).Encrypt(ctx, req.(*StreamingAeadEncryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamingAead_Decrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamingAeadDecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamingAeadServer).Decrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamingAead_Decrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamingAeadServer).Decrypt(ctx, req.(*StreamingAeadDecryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StreamingAead_ServiceDesc is the grpc.ServiceDesc for StreamingAead service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StreamingAead_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tink_testing_api.StreamingAead",
	HandlerType: (*StreamingAeadServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _StreamingAead_Create_Handler,
		},
		{
			MethodName: "Encrypt",
			Handler:    _StreamingAead_Encrypt_Handler,
		},
		{
			MethodName: "Decrypt",
			Handler:    _StreamingAead_Decrypt_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/protos/testing_api.proto",
}

const (
	Mac_Create_FullMethodName     = "/tink_testing_api.Mac/Create"
	Mac_ComputeMac_FullMethodName = "/tink_testing_api.Mac/ComputeMac"
	Mac_VerifyMac_FullMethodName  = "/tink_testing_api.Mac/VerifyMac"
)

// MacClient is the client API for Mac service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MacClient interface {
	// Creates a Mac object without using it.
	Create(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error)
	// Computes a MAC for given data. The client must call "Create" first to see
	// if creation succeeds before calling this.
	ComputeMac(ctx context.Context, in *ComputeMacRequest, opts ...grpc.CallOption) (*ComputeMacResponse, error)
	// Verifies the validity of the MAC value, no error means success. The client
	// must call "Create" first to see if creation succeeds before calling this.
	VerifyMac(ctx context.Context, in *VerifyMacRequest, opts ...grpc.CallOption) (*VerifyMacResponse, error)
}

type macClient struct {
	cc grpc.ClientConnInterface
}

func NewMacClient(cc grpc.ClientConnInterface) MacClient {
	return &macClient{cc}
}

func (c *macClient) Create(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error) {
	out := new(CreationResponse)
	err := c.cc.Invoke(ctx, Mac_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *macClient) ComputeMac(ctx context.Context, in *ComputeMacRequest, opts ...grpc.CallOption) (*ComputeMacResponse, error) {
	out := new(ComputeMacResponse)
	err := c.cc.Invoke(ctx, Mac_ComputeMac_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *macClient) VerifyMac(ctx context.Context, in *VerifyMacRequest, opts ...grpc.CallOption) (*VerifyMacResponse, error) {
	out := new(VerifyMacResponse)
	err := c.cc.Invoke(ctx, Mac_VerifyMac_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MacServer is the server API for Mac service.
// All implementations must embed UnimplementedMacServer
// for forward compatibility
type MacServer interface {
	// Creates a Mac object without using it.
	Create(context.Context, *CreationRequest) (*CreationResponse, error)
	// Computes a MAC for given data. The client must call "Create" first to see
	// if creation succeeds before calling this.
	ComputeMac(context.Context, *ComputeMacRequest) (*ComputeMacResponse, error)
	// Verifies the validity of the MAC value, no error means success. The client
	// must call "Create" first to see if creation succeeds before calling this.
	VerifyMac(context.Context, *VerifyMacRequest) (*VerifyMacResponse, error)
	mustEmbedUnimplementedMacServer()
}

// UnimplementedMacServer must be embedded to have forward compatible implementations.
type UnimplementedMacServer struct {
}

func (UnimplementedMacServer) Create(context.Context, *CreationRequest) (*CreationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedMacServer) ComputeMac(context.Context, *ComputeMacRequest) (*ComputeMacResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ComputeMac not implemented")
}
func (UnimplementedMacServer) VerifyMac(context.Context, *VerifyMacRequest) (*VerifyMacResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyMac not implemented")
}
func (UnimplementedMacServer) mustEmbedUnimplementedMacServer() {}

// UnsafeMacServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MacServer will
// result in compilation errors.
type UnsafeMacServer interface {
	mustEmbedUnimplementedMacServer()
}

func RegisterMacServer(s grpc.ServiceRegistrar, srv MacServer) {
	s.RegisterService(&Mac_ServiceDesc, srv)
}

func _Mac_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MacServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mac_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MacServer).Create(ctx, req.(*CreationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mac_ComputeMac_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComputeMacRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MacServer).ComputeMac(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mac_ComputeMac_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MacServer).ComputeMac(ctx, req.(*ComputeMacRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mac_VerifyMac_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyMacRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MacServer).VerifyMac(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mac_VerifyMac_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MacServer).VerifyMac(ctx, req.(*VerifyMacRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Mac_ServiceDesc is the grpc.ServiceDesc for Mac service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mac_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tink_testing_api.Mac",
	HandlerType: (*MacServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Mac_Create_Handler,
		},
		{
			MethodName: "ComputeMac",
			Handler:    _Mac_ComputeMac_Handler,
		},
		{
			MethodName: "VerifyMac",
			Handler:    _Mac_VerifyMac_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/protos/testing_api.proto",
}

const (
	Hybrid_CreateHybridEncrypt_FullMethodName = "/tink_testing_api.Hybrid/CreateHybridEncrypt"
	Hybrid_CreateHybridDecrypt_FullMethodName = "/tink_testing_api.Hybrid/CreateHybridDecrypt"
	Hybrid_Encrypt_FullMethodName             = "/tink_testing_api.Hybrid/Encrypt"
	Hybrid_Decrypt_FullMethodName             = "/tink_testing_api.Hybrid/Decrypt"
)

// HybridClient is the client API for Hybrid service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HybridClient interface {
	// Creates a HybridEncrypt object without using it.
	CreateHybridEncrypt(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error)
	// Creates a HybridDecrypt object without using it.
	CreateHybridDecrypt(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error)
	// Encrypts plaintext binding context_info to the resulting ciphertext. The
	// client must call "CreateHybridEncrypt" first to see if creation succeeds
	// before calling this.
	Encrypt(ctx context.Context, in *HybridEncryptRequest, opts ...grpc.CallOption) (*HybridEncryptResponse, error)
	// Decrypts ciphertext verifying the integrity of context_info. The client
	// must call "CreateHybridDecrypt" first to see if creation succeeds before
	// calling this.
	Decrypt(ctx context.Context, in *HybridDecryptRequest, opts ...grpc.CallOption) (*HybridDecryptResponse, error)
}

type hybridClient struct {
	cc grpc.ClientConnInterface
}

func NewHybridClient(cc grpc.ClientConnInterface) HybridClient {
	return &hybridClient{cc}
}

func (c *hybridClient) CreateHybridEncrypt(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error) {
	out := new(CreationResponse)
	err := c.cc.Invoke(ctx, Hybrid_CreateHybridEncrypt_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hybridClient) CreateHybridDecrypt(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error) {
	out := new(CreationResponse)
	err := c.cc.Invoke(ctx, Hybrid_CreateHybridDecrypt_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hybridClient) Encrypt(ctx context.Context, in *HybridEncryptRequest, opts ...grpc.CallOption) (*HybridEncryptResponse, error) {
	out := new(HybridEncryptResponse)
	err := c.cc.Invoke(ctx, Hybrid_Encrypt_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hybridClient) Decrypt(ctx context.Context, in *HybridDecryptRequest, opts ...grpc.CallOption) (*HybridDecryptResponse, error) {
	out := new(HybridDecryptResponse)
	err := c.cc.Invoke(ctx, Hybrid_Decrypt_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HybridServer is the server API for Hybrid service.
// All implementations must embed UnimplementedHybridServer
// for forward compatibility
type HybridServer interface {
	// Creates a HybridEncrypt object without using it.
	CreateHybridEncrypt(context.Context, *CreationRequest) (*CreationResponse, error)
	// Creates a HybridDecrypt object without using it.
	CreateHybridDecrypt(context.Context, *CreationRequest) (*CreationResponse, error)
	// Encrypts plaintext binding context_info to the resulting ciphertext. The
	// client must call "CreateHybridEncrypt" first to see if creation succeeds
	// before calling this.
	Encrypt(context.Context, *HybridEncryptRequest) (*HybridEncryptResponse, error)
	// Decrypts ciphertext verifying the integrity of context_info. The client
	// must call "CreateHybridDecrypt" first to see if creation succeeds before
	// calling this.
	Decrypt(context.Context, *HybridDecryptRequest) (*HybridDecryptResponse, error)
	mustEmbedUnimplementedHybridServer()
}

// UnimplementedHybridServer must be embedded to have forward compatible implementations.
type UnimplementedHybridServer struct {
}

func (UnimplementedHybridServer) CreateHybridEncrypt(context.Context, *CreationRequest) (*CreationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateHybridEncrypt not implemented")
}
func (UnimplementedHybridServer) CreateHybridDecrypt(context.Context, *CreationRequest) (*CreationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateHybridDecrypt not implemented")
}
func (UnimplementedHybridServer) Encrypt(context.Context, *HybridEncryptRequest) (*HybridEncryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Encrypt not implemented")
}
func (UnimplementedHybridServer) Decrypt(context.Context, *HybridDecryptRequest) (*HybridDecryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Decrypt not implemented")
}
func (UnimplementedHybridServer) mustEmbedUnimplementedHybridServer() {}

// UnsafeHybridServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HybridServer will
// result in compilation errors.
type UnsafeHybridServer interface {
	mustEmbedUnimplementedHybridServer()
}

func RegisterHybridServer(s grpc.ServiceRegistrar, srv HybridServer) {
	s.RegisterService(&Hybrid_ServiceDesc, srv)
}

func _Hybrid_CreateHybridEncrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HybridServer).CreateHybridEncrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hybrid_CreateHybridEncrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HybridServer).CreateHybridEncrypt(ctx, req.(*CreationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hybrid_CreateHybridDecrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HybridServer).CreateHybridDecrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hybrid_CreateHybridDecrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HybridServer).CreateHybridDecrypt(ctx, req.(*CreationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hybrid_Encrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HybridEncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HybridServer).Encrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hybrid_Encrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HybridServer).Encrypt(ctx, req.(*HybridEncryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hybrid_Decrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HybridDecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HybridServer).Decrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hybrid_Decrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HybridServer).Decrypt(ctx, req.(*HybridDecryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Hybrid_ServiceDesc is the grpc.ServiceDesc for Hybrid service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Hybrid_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tink_testing_api.Hybrid",
	HandlerType: (*HybridServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateHybridEncrypt",
			Handler:    _Hybrid_CreateHybridEncrypt_Handler,
		},
		{
			MethodName: "CreateHybridDecrypt",
			Handler:    _Hybrid_CreateHybridDecrypt_Handler,
		},
		{
			MethodName: "Encrypt",
			Handler:    _Hybrid_Encrypt_Handler,
		},
		{
			MethodName: "Decrypt",
			Handler:    _Hybrid_Decrypt_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/protos/testing_api.proto",
}

const (
	Signature_CreatePublicKeySign_FullMethodName   = "/tink_testing_api.Signature/CreatePublicKeySign"
	Signature_CreatePublicKeyVerify_FullMethodName = "/tink_testing_api.Signature/CreatePublicKeyVerify"
	Signature_Sign_FullMethodName                  = "/tink_testing_api.Signature/Sign"
	Signature_Verify_FullMethodName                = "/tink_testing_api.Signature/Verify"
)

// SignatureClient is the client API for Signature service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SignatureClient interface {
	// Creates a PublicKeySign object without using it.
	CreatePublicKeySign(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error)
	// Creates a PublicKeyVerify object without using it.
	CreatePublicKeyVerify(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error)
	// Computes the signature for data. The client must call "CreatePublicKeySign"
	// first to see if creation succeeds before calling this.
	Sign(ctx context.Context, in *SignatureSignRequest, opts ...grpc.CallOption) (*SignatureSignResponse, error)
	// Verifies that signature is a digital signature for data. The client must
	// call "CreatePublicKeyVerify" first to see if creation succeeds before
	// calling this.
	Verify(ctx context.Context, in *SignatureVerifyRequest, opts ...grpc.CallOption) (*SignatureVerifyResponse, error)
}

type signatureClient struct {
	cc grpc.ClientConnInterface
}

func NewSignatureClient(cc grpc.ClientConnInterface) SignatureClient {
	return &signatureClient{cc}
}

func (c *signatureClient) CreatePublicKeySign(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error) {
	out := new(CreationResponse)
	err := c.cc.Invoke(ctx, Signature_CreatePublicKeySign_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signatureClient) CreatePublicKeyVerify(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error) {
	out := new(CreationResponse)
	err := c.cc.Invoke(ctx, Signature_CreatePublicKeyVerify_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signatureClient) Sign(ctx context.Context, in *SignatureSignRequest, opts ...grpc.CallOption) (*SignatureSignResponse, error) {
	out := new(SignatureSignResponse)
	err := c.cc.Invoke(ctx, Signature_Sign_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signatureClient) Verify(ctx context.Context, in *SignatureVerifyRequest, opts ...grpc.CallOption) (*SignatureVerifyResponse, error) {
	out := new(SignatureVerifyResponse)
	err := c.cc.Invoke(ctx, Signature_Verify_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SignatureServer is the server API for Signature service.
// All implementations must embed UnimplementedSignatureServer
// for forward compatibility
type SignatureServer interface {
	// Creates a PublicKeySign object without using it.
	CreatePublicKeySign(context.Context, *CreationRequest) (*CreationResponse, error)
	// Creates a PublicKeyVerify object without using it.
	CreatePublicKeyVerify(context.Context, *CreationRequest) (*CreationResponse, error)
	// Computes the signature for data. The client must call "CreatePublicKeySign"
	// first to see if creation succeeds before calling this.
	Sign(context.Context, *SignatureSignRequest) (*SignatureSignResponse, error)
	// Verifies that signature is a digital signature for data. The client must
	// call "CreatePublicKeyVerify" first to see if creation succeeds before
	// calling this.
	Verify(context.Context, *SignatureVerifyRequest) (*SignatureVerifyResponse, error)
	mustEmbedUnimplementedSignatureServer()
}

// UnimplementedSignatureServer must be embedded to have forward compatible implementations.
type UnimplementedSignatureServer struct {
}

func (UnimplementedSignatureServer) CreatePublicKeySign(context.Context, *CreationRequest) (*CreationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePublicKeySign not implemented")
}
func (UnimplementedSignatureServer) CreatePublicKeyVerify(context.Context, *CreationRequest) (*CreationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePublicKeyVerify not implemented")
}
func (UnimplementedSignatureServer) Sign(context.Context, *SignatureSignRequest) (*SignatureSignResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sign not implemented")
}
func (UnimplementedSignatureServer) Verify(context.Context, *SignatureVerifyRequest) (*SignatureVerifyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Verify not implemented")
}
func (UnimplementedSignatureServer) mustEmbedUnimplementedSignatureServer() {}

// UnsafeSignatureServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SignatureServer will
// result in compilation errors.
type UnsafeSignatureServer interface {
	mustEmbedUnimplementedSignatureServer()
}

func RegisterSignatureServer(s grpc.ServiceRegistrar, srv SignatureServer) {
	s.RegisterService(&Signature_ServiceDesc, srv)
}

func _Signature_CreatePublicKeySign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignatureServer).CreatePublicKeySign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Signature_CreatePublicKeySign_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignatureServer).CreatePublicKeySign(ctx, req.(*CreationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signature_CreatePublicKeyVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignatureServer).CreatePublicKeyVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Signature_CreatePublicKeyVerify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignatureServer).CreatePublicKeyVerify(ctx, req.(*CreationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signature_Sign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignatureSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignatureServer).Sign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Signature_Sign_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignatureServer).Sign(ctx, req.(*SignatureSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Signature_Verify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignatureVerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignatureServer).Verify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Signature_Verify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignatureServer).Verify(ctx, req.(*SignatureVerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Signature_ServiceDesc is the grpc.ServiceDesc for Signature service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Signature_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tink_testing_api.Signature",
	HandlerType: (*SignatureServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePublicKeySign",
			Handler:    _Signature_CreatePublicKeySign_Handler,
		},
		{
			MethodName: "CreatePublicKeyVerify",
			Handler:    _Signature_CreatePublicKeyVerify_Handler,
		},
		{
			MethodName: "Sign",
			Handler:    _Signature_Sign_Handler,
		},
		{
			MethodName: "Verify",
			Handler:    _Signature_Verify_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/protos/testing_api.proto",
}

const (
	PrfSet_Create_FullMethodName  = "/tink_testing_api.PrfSet/Create"
	PrfSet_KeyIds_FullMethodName  = "/tink_testing_api.PrfSet/KeyIds"
	PrfSet_Compute_FullMethodName = "/tink_testing_api.PrfSet/Compute"
)

// PrfSetClient is the client API for PrfSet service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PrfSetClient interface {
	// Creates a PrfSet object without using it.
	Create(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error)
	// Returns the key ids and the primary key id in the keyset.The client must
	// call "Create" first to see if creation succeeds before calling this.
	KeyIds(ctx context.Context, in *PrfSetKeyIdsRequest, opts ...grpc.CallOption) (*PrfSetKeyIdsResponse, error)
	// Computes the output of the PRF with the given key_id in the PrfSet.The
	// client must call "Create" first to see if creation succeeds before calling
	// this.
	Compute(ctx context.Context, in *PrfSetComputeRequest, opts ...grpc.CallOption) (*PrfSetComputeResponse, error)
}

type prfSetClient struct {
	cc grpc.ClientConnInterface
}

func NewPrfSetClient(cc grpc.ClientConnInterface) PrfSetClient {
	return &prfSetClient{cc}
}

func (c *prfSetClient) Create(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error) {
	out := new(CreationResponse)
	err := c.cc.Invoke(ctx, PrfSet_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prfSetClient) KeyIds(ctx context.Context, in *PrfSetKeyIdsRequest, opts ...grpc.CallOption) (*PrfSetKeyIdsResponse, error) {
	out := new(PrfSetKeyIdsResponse)
	err := c.cc.Invoke(ctx, PrfSet_KeyIds_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prfSetClient) Compute(ctx context.Context, in *PrfSetComputeRequest, opts ...grpc.CallOption) (*PrfSetComputeResponse, error) {
	out := new(PrfSetComputeResponse)
	err := c.cc.Invoke(ctx, PrfSet_Compute_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PrfSetServer is the server API for PrfSet service.
// All implementations must embed UnimplementedPrfSetServer
// for forward compatibility
type PrfSetServer interface {
	// Creates a PrfSet object without using it.
	Create(context.Context, *CreationRequest) (*CreationResponse, error)
	// Returns the key ids and the primary key id in the keyset.The client must
	// call "Create" first to see if creation succeeds before calling this.
	KeyIds(context.Context, *PrfSetKeyIdsRequest) (*PrfSetKeyIdsResponse, error)
	// Computes the output of the PRF with the given key_id in the PrfSet.The
	// client must call "Create" first to see if creation succeeds before calling
	// this.
	Compute(context.Context, *PrfSetComputeRequest) (*PrfSetComputeResponse, error)
	mustEmbedUnimplementedPrfSetServer()
}

// UnimplementedPrfSetServer must be embedded to have forward compatible implementations.
type UnimplementedPrfSetServer struct {
}

func (UnimplementedPrfSetServer) Create(context.Context, *CreationRequest) (*CreationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedPrfSetServer) KeyIds(context.Context, *PrfSetKeyIdsRequest) (*PrfSetKeyIdsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KeyIds not implemented")
}
func (UnimplementedPrfSetServer) Compute(context.Context, *PrfSetComputeRequest) (*PrfSetComputeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Compute not implemented")
}
func (UnimplementedPrfSetServer) mustEmbedUnimplementedPrfSetServer() {}

// UnsafePrfSetServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PrfSetServer will
// result in compilation errors.
type UnsafePrfSetServer interface {
	mustEmbedUnimplementedPrfSetServer()
}

func RegisterPrfSetServer(s grpc.ServiceRegistrar, srv PrfSetServer) {
	s.RegisterService(&PrfSet_ServiceDesc, srv)
}

func _PrfSet_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrfSetServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrfSet_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrfSetServer).Create(ctx, req.(*CreationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrfSet_KeyIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrfSetKeyIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrfSetServer).KeyIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrfSet_KeyIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrfSetServer).KeyIds(ctx, req.(*PrfSetKeyIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrfSet_Compute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrfSetComputeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrfSetServer).Compute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrfSet_Compute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrfSetServer).Compute(ctx, req.(*PrfSetComputeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PrfSet_ServiceDesc is the grpc.ServiceDesc for PrfSet service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PrfSet_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tink_testing_api.PrfSet",
	HandlerType: (*PrfSetServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _PrfSet_Create_Handler,
		},
		{
			MethodName: "KeyIds",
			Handler:    _PrfSet_KeyIds_Handler,
		},
		{
			MethodName: "Compute",
			Handler:    _PrfSet_Compute_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/protos/testing_api.proto",
}

const (
	Jwt_CreateJwtMac_FullMethodName             = "/tink_testing_api.Jwt/CreateJwtMac"
	Jwt_CreateJwtPublicKeySign_FullMethodName   = "/tink_testing_api.Jwt/CreateJwtPublicKeySign"
	Jwt_CreateJwtPublicKeyVerify_FullMethodName = "/tink_testing_api.Jwt/CreateJwtPublicKeyVerify"
	Jwt_ComputeMacAndEncode_FullMethodName      = "/tink_testing_api.Jwt/ComputeMacAndEncode"
	Jwt_VerifyMacAndDecode_FullMethodName       = "/tink_testing_api.Jwt/VerifyMacAndDecode"
	Jwt_PublicKeySignAndEncode_FullMethodName   = "/tink_testing_api.Jwt/PublicKeySignAndEncode"
	Jwt_PublicKeyVerifyAndDecode_FullMethodName = "/tink_testing_api.Jwt/PublicKeyVerifyAndDecode"
	Jwt_ToJwkSet_FullMethodName                 = "/tink_testing_api.Jwt/ToJwkSet"
	Jwt_FromJwkSet_FullMethodName               = "/tink_testing_api.Jwt/FromJwkSet"
)

// JwtClient is the client API for Jwt service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type JwtClient interface {
	// Creates a JwtMac object without using it.
	CreateJwtMac(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error)
	// Creates a JwtPublicKeySign object without using it.
	CreateJwtPublicKeySign(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error)
	// Creates a JwtPublicKeyVerify object without using it.
	CreateJwtPublicKeyVerify(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error)
	// Computes a signed compact JWT token.
	ComputeMacAndEncode(ctx context.Context, in *JwtSignRequest, opts ...grpc.CallOption) (*JwtSignResponse, error)
	// Verifies the validity of the signed compact JWT token
	VerifyMacAndDecode(ctx context.Context, in *JwtVerifyRequest, opts ...grpc.CallOption) (*JwtVerifyResponse, error)
	// Computes a signed compact JWT token.
	PublicKeySignAndEncode(ctx context.Context, in *JwtSignRequest, opts ...grpc.CallOption) (*JwtSignResponse, error)
	// Verifies the validity of the signed compact JWT token
	PublicKeyVerifyAndDecode(ctx context.Context, in *JwtVerifyRequest, opts ...grpc.CallOption) (*JwtVerifyResponse, error)
	// Converts a Keyset from Tink Binary to JWK Set Format
	ToJwkSet(ctx context.Context, in *JwtToJwkSetRequest, opts ...grpc.CallOption) (*JwtToJwkSetResponse, error)
	// Converts a Keyset from JWK Set to Tink Binary Format
	FromJwkSet(ctx context.Context, in *JwtFromJwkSetRequest, opts ...grpc.CallOption) (*JwtFromJwkSetResponse, error)
}

type jwtClient struct {
	cc grpc.ClientConnInterface
}

func NewJwtClient(cc grpc.ClientConnInterface) JwtClient {
	return &jwtClient{cc}
}

func (c *jwtClient) CreateJwtMac(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error) {
	out := new(CreationResponse)
	err := c.cc.Invoke(ctx, Jwt_CreateJwtMac_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jwtClient) CreateJwtPublicKeySign(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error) {
	out := new(CreationResponse)
	err := c.cc.Invoke(ctx, Jwt_CreateJwtPublicKeySign_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jwtClient) CreateJwtPublicKeyVerify(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error) {
	out := new(CreationResponse)
	err := c.cc.Invoke(ctx, Jwt_CreateJwtPublicKeyVerify_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jwtClient) ComputeMacAndEncode(ctx context.Context, in *JwtSignRequest, opts ...grpc.CallOption) (*JwtSignResponse, error) {
	out := new(JwtSignResponse)
	err := c.cc.Invoke(ctx, Jwt_ComputeMacAndEncode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jwtClient) VerifyMacAndDecode(ctx context.Context, in *JwtVerifyRequest, opts ...grpc.CallOption) (*JwtVerifyResponse, error) {
	out := new(JwtVerifyResponse)
	err := c.cc.Invoke(ctx, Jwt_VerifyMacAndDecode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jwtClient) PublicKeySignAndEncode(ctx context.Context, in *JwtSignRequest, opts ...grpc.CallOption) (*JwtSignResponse, error) {
	out := new(JwtSignResponse)
	err := c.cc.Invoke(ctx, Jwt_PublicKeySignAndEncode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jwtClient) PublicKeyVerifyAndDecode(ctx context.Context, in *JwtVerifyRequest, opts ...grpc.CallOption) (*JwtVerifyResponse, error) {
	out := new(JwtVerifyResponse)
	err := c.cc.Invoke(ctx, Jwt_PublicKeyVerifyAndDecode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jwtClient) ToJwkSet(ctx context.Context, in *JwtToJwkSetRequest, opts ...grpc.CallOption) (*JwtToJwkSetResponse, error) {
	out := new(JwtToJwkSetResponse)
	err := c.cc.Invoke(ctx, Jwt_ToJwkSet_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jwtClient) FromJwkSet(ctx context.Context, in *JwtFromJwkSetRequest, opts ...grpc.CallOption) (*JwtFromJwkSetResponse, error) {
	out := new(JwtFromJwkSetResponse)
	err := c.cc.Invoke(ctx, Jwt_FromJwkSet_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JwtServer is the server API for Jwt service.
// All implementations must embed UnimplementedJwtServer
// for forward compatibility
type JwtServer interface {
	// Creates a JwtMac object without using it.
	CreateJwtMac(context.Context, *CreationRequest) (*CreationResponse, error)
	// Creates a JwtPublicKeySign object without using it.
	CreateJwtPublicKeySign(context.Context, *CreationRequest) (*CreationResponse, error)
	// Creates a JwtPublicKeyVerify object without using it.
	CreateJwtPublicKeyVerify(context.Context, *CreationRequest) (*CreationResponse, error)
	// Computes a signed compact JWT token.
	ComputeMacAndEncode(context.Context, *JwtSignRequest) (*JwtSignResponse, error)
	// Verifies the validity of the signed compact JWT token
	VerifyMacAndDecode(context.Context, *JwtVerifyRequest) (*JwtVerifyResponse, error)
	// Computes a signed compact JWT token.
	PublicKeySignAndEncode(context.Context, *JwtSignRequest) (*JwtSignResponse, error)
	// Verifies the validity of the signed compact JWT token
	PublicKeyVerifyAndDecode(context.Context, *JwtVerifyRequest) (*JwtVerifyResponse, error)
	// Converts a Keyset from Tink Binary to JWK Set Format
	ToJwkSet(context.Context, *JwtToJwkSetRequest) (*JwtToJwkSetResponse, error)
	// Converts a Keyset from JWK Set to Tink Binary Format
	FromJwkSet(context.Context, *JwtFromJwkSetRequest) (*JwtFromJwkSetResponse, error)
	mustEmbedUnimplementedJwtServer()
}

// UnimplementedJwtServer must be embedded to have forward compatible implementations.
type UnimplementedJwtServer struct {
}

func (UnimplementedJwtServer) CreateJwtMac(context.Context, *CreationRequest) (*CreationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateJwtMac not implemented")
}
func (UnimplementedJwtServer) CreateJwtPublicKeySign(context.Context, *CreationRequest) (*CreationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateJwtPublicKeySign not implemented")
}
func (UnimplementedJwtServer) CreateJwtPublicKeyVerify(context.Context, *CreationRequest) (*CreationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateJwtPublicKeyVerify not implemented")
}
func (UnimplementedJwtServer) ComputeMacAndEncode(context.Context, *JwtSignRequest) (*JwtSignResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ComputeMacAndEncode not implemented")
}
func (UnimplementedJwtServer) VerifyMacAndDecode(context.Context, *JwtVerifyRequest) (*JwtVerifyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyMacAndDecode not implemented")
}
func (UnimplementedJwtServer) PublicKeySignAndEncode(context.Context, *JwtSignRequest) (*JwtSignResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublicKeySignAndEncode not implemented")
}
func (UnimplementedJwtServer) PublicKeyVerifyAndDecode(context.Context, *JwtVerifyRequest) (*JwtVerifyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublicKeyVerifyAndDecode not implemented")
}
func (UnimplementedJwtServer) ToJwkSet(context.Context, *JwtToJwkSetRequest) (*JwtToJwkSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToJwkSet not implemented")
}
func (UnimplementedJwtServer) FromJwkSet(context.Context, *JwtFromJwkSetRequest) (*JwtFromJwkSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FromJwkSet not implemented")
}
func (UnimplementedJwtServer) mustEmbedUnimplementedJwtServer() {}

// UnsafeJwtServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JwtServer will
// result in compilation errors.
type UnsafeJwtServer interface {
	mustEmbedUnimplementedJwtServer()
}

func RegisterJwtServer(s grpc.ServiceRegistrar, srv JwtServer) {
	s.RegisterService(&Jwt_ServiceDesc, srv)
}

func _Jwt_CreateJwtMac_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JwtServer).CreateJwtMac(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Jwt_CreateJwtMac_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JwtServer).CreateJwtMac(ctx, req.(*CreationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Jwt_CreateJwtPublicKeySign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JwtServer).CreateJwtPublicKeySign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Jwt_CreateJwtPublicKeySign_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JwtServer).CreateJwtPublicKeySign(ctx, req.(*CreationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Jwt_CreateJwtPublicKeyVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JwtServer).CreateJwtPublicKeyVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Jwt_CreateJwtPublicKeyVerify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JwtServer).CreateJwtPublicKeyVerify(ctx, req.(*CreationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Jwt_ComputeMacAndEncode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JwtSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JwtServer).ComputeMacAndEncode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Jwt_ComputeMacAndEncode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JwtServer).ComputeMacAndEncode(ctx, req.(*JwtSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Jwt_VerifyMacAndDecode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JwtVerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JwtServer).VerifyMacAndDecode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Jwt_VerifyMacAndDecode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JwtServer).VerifyMacAndDecode(ctx, req.(*JwtVerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Jwt_PublicKeySignAndEncode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JwtSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JwtServer).PublicKeySignAndEncode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Jwt_PublicKeySignAndEncode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JwtServer).PublicKeySignAndEncode(ctx, req.(*JwtSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Jwt_PublicKeyVerifyAndDecode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JwtVerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JwtServer).PublicKeyVerifyAndDecode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Jwt_PublicKeyVerifyAndDecode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JwtServer).PublicKeyVerifyAndDecode(ctx, req.(*JwtVerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Jwt_ToJwkSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JwtToJwkSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JwtServer).ToJwkSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Jwt_ToJwkSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JwtServer).ToJwkSet(ctx, req.(*JwtToJwkSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Jwt_FromJwkSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JwtFromJwkSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JwtServer).FromJwkSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Jwt_FromJwkSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JwtServer).FromJwkSet(ctx, req.(*JwtFromJwkSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Jwt_ServiceDesc is the grpc.ServiceDesc for Jwt service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Jwt_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tink_testing_api.Jwt",
	HandlerType: (*JwtServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateJwtMac",
			Handler:    _Jwt_CreateJwtMac_Handler,
		},
		{
			MethodName: "CreateJwtPublicKeySign",
			Handler:    _Jwt_CreateJwtPublicKeySign_Handler,
		},
		{
			MethodName: "CreateJwtPublicKeyVerify",
			Handler:    _Jwt_CreateJwtPublicKeyVerify_Handler,
		},
		{
			MethodName: "ComputeMacAndEncode",
			Handler:    _Jwt_ComputeMacAndEncode_Handler,
		},
		{
			MethodName: "VerifyMacAndDecode",
			Handler:    _Jwt_VerifyMacAndDecode_Handler,
		},
		{
			MethodName: "PublicKeySignAndEncode",
			Handler:    _Jwt_PublicKeySignAndEncode_Handler,
		},
		{
			MethodName: "PublicKeyVerifyAndDecode",
			Handler:    _Jwt_PublicKeyVerifyAndDecode_Handler,
		},
		{
			MethodName: "ToJwkSet",
			Handler:    _Jwt_ToJwkSet_Handler,
		},
		{
			MethodName: "FromJwkSet",
			Handler:    _Jwt_FromJwkSet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/protos/testing_api.proto",
}

const (
	KeysetDeriver_Create_FullMethodName       = "/tink_testing_api.KeysetDeriver/Create"
	KeysetDeriver_DeriveKeyset_FullMethodName = "/tink_testing_api.KeysetDeriver/DeriveKeyset"
)

// KeysetDeriverClient is the client API for KeysetDeriver service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KeysetDeriverClient interface {
	// Creates an KeysetDeriver object.
	Create(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error)
	// Derives keyset. The client must successfully call "Create" first.
	DeriveKeyset(ctx context.Context, in *DeriveKeysetRequest, opts ...grpc.CallOption) (*DeriveKeysetResponse, error)
}

type keysetDeriverClient struct {
	cc grpc.ClientConnInterface
}

func NewKeysetDeriverClient(cc grpc.ClientConnInterface) KeysetDeriverClient {
	return &keysetDeriverClient{cc}
}

func (c *keysetDeriverClient) Create(ctx context.Context, in *CreationRequest, opts ...grpc.CallOption) (*CreationResponse, error) {
	out := new(CreationResponse)
	err := c.cc.Invoke(ctx, KeysetDeriver_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysetDeriverClient) DeriveKeyset(ctx context.Context, in *DeriveKeysetRequest, opts ...grpc.CallOption) (*DeriveKeysetResponse, error) {
	out := new(DeriveKeysetResponse)
	err := c.cc.Invoke(ctx, KeysetDeriver_DeriveKeyset_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KeysetDeriverServer is the server API for KeysetDeriver service.
// All implementations must embed UnimplementedKeysetDeriverServer
// for forward compatibility
type KeysetDeriverServer interface {
	// Creates an KeysetDeriver object.
	Create(context.Context, *CreationRequest) (*CreationResponse, error)
	// Derives keyset. The client must successfully call "Create" first.
	DeriveKeyset(context.Context, *DeriveKeysetRequest) (*DeriveKeysetResponse, error)
	mustEmbedUnimplementedKeysetDeriverServer()
}

// UnimplementedKeysetDeriverServer must be embedded to have forward compatible implementations.
type UnimplementedKeysetDeriverServer struct {
}

func (UnimplementedKeysetDeriverServer) Create(context.Context, *CreationRequest) (*CreationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedKeysetDeriverServer) DeriveKeyset(context.Context, *DeriveKeysetRequest) (*DeriveKeysetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeriveKeyset not implemented")
}
func (UnimplementedKeysetDeriverServer) mustEmbedUnimplementedKeysetDeriverServer() {}

// UnsafeKeysetDeriverServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KeysetDeriverServer will
// result in compilation errors.
type UnsafeKeysetDeriverServer interface {
	mustEmbedUnimplementedKeysetDeriverServer()
}

func RegisterKeysetDeriverServer(s grpc.ServiceRegistrar, srv KeysetDeriverServer) {
	s.RegisterService(&KeysetDeriver_ServiceDesc, srv)
}

func _KeysetDeriver_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysetDeriverServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeysetDeriver_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysetDeriverServer).Create(ctx, req.(*CreationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeysetDeriver_DeriveKeyset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeriveKeysetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysetDeriverServer).DeriveKeyset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeysetDeriver_DeriveKeyset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysetDeriverServer).DeriveKeyset(ctx, req.(*DeriveKeysetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KeysetDeriver_ServiceDesc is the grpc.ServiceDesc for KeysetDeriver service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KeysetDeriver_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tink_testing_api.KeysetDeriver",
	HandlerType: (*KeysetDeriverServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _KeysetDeriver_Create_Handler,
		},
		{
			MethodName: "DeriveKeyset",
			Handler:    _KeysetDeriver_DeriveKeyset_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/protos/testing_api.proto",
}
